"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const datasource_toolkit_1 = require("@forestadmin/datasource-toolkit");
const sequelize_1 = require("sequelize");
const un_ambigous_1 = __importDefault(require("./un-ambigous"));
class QueryConverter {
    constructor(model) {
        this.model = model;
        this.dialect = this.model.sequelize.getDialect();
        this.col = this.model.sequelize.col;
        this.fn = this.model.sequelize.fn;
        this.where = this.model.sequelize.where;
    }
    asArray(value) {
        if (!Array.isArray(value))
            return [value];
        return value;
    }
    makeWhereClause(field, operator, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    value) {
        if (operator === null)
            throw new Error('Invalid (null) operator.');
        switch (operator) {
            case 'Blank':
                return {
                    [sequelize_1.Op.or]: [this.makeWhereClause(field, 'Missing'), { [sequelize_1.Op.eq]: '' }],
                };
            case 'Like':
                if (this.dialect === 'sqlite')
                    return this.where(this.col(field), 'GLOB', value.replace(/%/g, '*').replace(/_/g, '?'));
                if (this.dialect === 'mysql' || this.dialect === 'mariadb')
                    return this.where(this.fn('BINARY', this.col(field)), 'LIKE', value);
                return { [sequelize_1.Op.like]: value };
            case 'ILike':
                if (this.dialect === 'postgres')
                    return { [sequelize_1.Op.iLike]: value };
                if (this.dialect === 'mysql' || this.dialect === 'mariadb' || this.dialect === 'sqlite')
                    return { [sequelize_1.Op.like]: value };
                return this.where(this.fn('LOWER', this.col(field)), 'LIKE', value.toLocaleLowerCase());
            case 'NotContains':
                return {
                    [sequelize_1.Op.not]: this.makeWhereClause(field, 'Like', `%${value}%`),
                };
            case 'Equal':
                return { [sequelize_1.Op.eq]: value };
            case 'GreaterThan':
                return { [sequelize_1.Op.gt]: value };
            case 'In':
                return { [sequelize_1.Op.in]: this.asArray(value) };
            case 'IncludesAll':
                return { [sequelize_1.Op.contains]: this.asArray(value) };
            case 'LessThan':
                return { [sequelize_1.Op.lt]: value };
            case 'Missing':
                return { [sequelize_1.Op.is]: null };
            case 'NotEqual':
                return { [sequelize_1.Op.ne]: value };
            case 'NotIn':
                return { [sequelize_1.Op.notIn]: this.asArray(value) };
            case 'Present':
                return { [sequelize_1.Op.ne]: null };
            default:
                throw new Error(`Unsupported operator: "${operator}".`);
        }
    }
    /*
     * Delete and update sequelize methods does not provide the include options.
     * This method is developed to by pass this problem.
     */
    async getWhereFromConditionTreeToByPassInclude(conditionTree) {
        const include = conditionTree ? this.getIncludeFromProjection(conditionTree.projection) : [];
        const whereOptions = this.getWhereFromConditionTree(conditionTree);
        if (include.length === 0) {
            return whereOptions;
        }
        const keys = [...this.model.primaryKeyAttributes];
        const records = await this.model.findAll({ attributes: keys, where: whereOptions, include });
        const conditions = records.map(record => {
            const equals = keys.map(pk => new datasource_toolkit_1.ConditionTreeLeaf(pk, 'Equal', record.get(pk)));
            return datasource_toolkit_1.ConditionTreeFactory.intersect(...equals);
        });
        const union = datasource_toolkit_1.ConditionTreeFactory.union(...conditions);
        return this.getWhereFromConditionTree(union);
    }
    getWhereFromConditionTree(conditionTree) {
        if (!conditionTree)
            return {};
        const sequelizeWhereClause = {};
        if (conditionTree.aggregator !== undefined) {
            const { aggregator, conditions } = conditionTree;
            if (aggregator === null) {
                throw new Error('Invalid (null) aggregator.');
            }
            const sequelizeOperator = aggregator === 'And' ? sequelize_1.Op.and : sequelize_1.Op.or;
            if (!Array.isArray(conditions)) {
                throw new Error('Conditions must be an array.');
            }
            sequelizeWhereClause[sequelizeOperator] = conditions.map(condition => this.getWhereFromConditionTree(condition));
        }
        else if (conditionTree.operator !== undefined) {
            const { field, operator, value } = conditionTree;
            const isRelation = field.includes(':');
            const safeField = (0, un_ambigous_1.default)(this.model, field);
            sequelizeWhereClause[isRelation ? `$${safeField}$` : safeField] = this.makeWhereClause(safeField, operator, value);
        }
        else {
            throw new Error('Invalid ConditionTree.');
        }
        return sequelizeWhereClause;
    }
    computeIncludeFromProjection(projection, withAttributes = true) {
        return Object.entries(projection.relations).map(([relationName, relationProjection]) => {
            return {
                association: relationName,
                attributes: withAttributes ? relationProjection.columns : [],
                include: this.computeIncludeFromProjection(relationProjection, withAttributes),
            };
        });
    }
    getIncludeFromProjection(projection) {
        return this.computeIncludeFromProjection(projection, false);
    }
    getIncludeWithAttributesFromProjection(projection) {
        return this.computeIncludeFromProjection(projection);
    }
    getOrderFromSort(sort) {
        return (sort ?? []).map(({ field, ascending }) => {
            const path = field.split(':');
            return [...path, ascending ? 'ASC' : 'DESC'];
        });
    }
}
exports.default = QueryConverter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicXVlcnktY29udmVydGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3V0aWxzL3F1ZXJ5LWNvbnZlcnRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLHdFQVF5QztBQUN6Qyx5Q0FTbUI7QUFFbkIsZ0VBQTRDO0FBRTVDLE1BQXFCLGNBQWM7SUFPakMsWUFBWSxLQUFxQztRQUMvQyxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLFVBQVUsRUFBYSxDQUFDO1FBQzVELElBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDO1FBQ3BDLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDO1FBQ2xDLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDO0lBQzFDLENBQUM7SUFFTyxPQUFPLENBQUMsS0FBYztRQUM1QixJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUM7WUFBRSxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFMUMsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRU8sZUFBZSxDQUNyQixLQUFhLEVBQ2IsUUFBa0I7SUFDbEIsOERBQThEO0lBQzlELEtBQVc7UUFHWCxJQUFJLFFBQVEsS0FBSyxJQUFJO1lBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQywwQkFBMEIsQ0FBQyxDQUFDO1FBRW5FLFFBQVEsUUFBUSxFQUFFO1lBQ2hCLEtBQUssT0FBTztnQkFDVixPQUFPO29CQUNMLENBQUMsY0FBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLEVBQUUsU0FBUyxDQUFD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